{
  parserClass="io.runescript.plugin.lang.parser.RsParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Rs"
  psiImplClassSuffix="Impl"
  psiPackage="io.runescript.plugin.lang.psi"
  psiImplPackage="io.runescript.plugin.lang.psi.impl"
  psiImplUtilClass="io.runescript.plugin.lang.psi.RsPsiImplUtil"
  elementTypeHolderClass="io.runescript.plugin.lang.psi.RsTypes"
  elementTypeClass="io.runescript.plugin.lang.psi.RsElementType"
  tokenTypeClass="io.runescript.plugin.lang.psi.RsElementType"
  generateTokenAccessors=true
  name(".*Expression")='Expression'
  extends(".*Expression")=Expression
  name(".*Statement")='Statement'
  extends(".*Statement")=Statement
  classHeader="// This class is automatically generated. Do not edit."

  tokens=[
    LBRACKET='['
    RBRACKET=']'
    LPAREN='('
    RPAREN=')'
    LBRACE='{'
    RBRACE='}'
    COMMA=','
    COLON=':'
    SEMICOLON=';'
    EQUAL='='
    EXCEL='!'
    GT='>'
    LT='<'
    GTE='>='
    LTE='<='
    BAR='|'
    AMPERSAND='&'
    PLUS='+'
    MINUS='-'
    STAR='*'
    SLASH='/'
    PERCENT='%'
    CARET='^'
    TILDE='~'
  ]
}

File ::= Script*
Script ::= ScriptHeader StatementList
ScriptHeader ::= ScriptName ParameterList? ReturnList?
ScriptName ::= '[' NameLiteral ',' NameLiteral ']'

ParameterList ::= '(' (parameter (',' parameter)*)? ')'
parameter ::= (TYPE_NAME | ARRAY_TYPE_NAME) LocalVariableExpression
ReturnList ::= '(' (TYPE_NAME (',' TYPE_NAME)*)? ')'
StatementList ::= Statement*
Statement ::= BlockStatement
            | IfStatement
            | WhileStatement
            | SwitchStatement
            | ReturnStatement
            | LocalVariableDeclarationStatement
            | LocalVariableAssignmentStatement
            | ArrayVariableDeclarationStatement
            | ArrayVariableAssignmentStatement
            | ScopedVariableAssignmentStatement
            | ExpressionStatement

BlockStatement ::= '{' StatementList '}'
IfStatement ::= IF '(' RelationalExpression ')' Statement
WhileStatement ::= WHILE '(' RelationalExpression ')' Statement
SwitchStatement ::= SWITCH '(' Expression ')' '{' SwitchCase* '}'
SwitchCase ::= CASE SwitchCaseExpressionList ':' StatementList
private SwitchCaseExpressionList ::= SwitchCaseExpression (',' SwitchCaseExpression)*
private SwitchCaseExpression ::= Expression | DEFAULT
ReturnStatement ::= RETURN ('(' ExpressionList? ')')? ';'
LocalVariableDeclarationStatement ::= DEFINE_TYPE LocalVariableExpression ('=' Expression)? ';' {
    methods=[getNameExpression]
}
LocalVariableAssignmentStatement ::= LocalVariableExpression '=' Expression ';'
ArrayVariableDeclarationStatement ::= DEFINE_TYPE LocalVariableExpression ParExpression ';'
ArrayVariableAssignmentStatement ::= LocalVariableExpression ParExpression '=' Expression ';'
ScopedVariableAssignmentStatement ::= ScopedVariableExpression '=' Expression ';'
ExpressionStatement ::= Expression ';'

// Relational Expressions

private RelationalExpression ::= LogicalOrWrapper

private LogicalOrWrapper ::= LogicalAndWrapper LogicalOrExpression*
left LogicalOrExpression ::= '|' LogicalAndWrapper

private LogicalAndWrapper ::= CompareExpressionWrapper LogicalAndExpression*
left LogicalAndExpression ::= '&' CompareExpressionWrapper

private CompareExpressionWrapper ::= RelationalValueExpression CompareExpression?
left CompareExpression ::= ('!' | '>' | '<' | '>=' | '<=' | '=') RelationalValueExpression

RelationalValueExpression ::= ('(' RelationalExpression ')') | Expression

// Arithmetic & Bitwise Expressions

ArithmeticExpression ::= ArithmeticBitwiseOrWrapper

private ArithmeticBitwiseOrWrapper ::= ArithmeticBitwiseAndWrapper ArithmeticBitwiseOrExpression*
left ArithmeticBitwiseOrExpression ::= '|' ArithmeticBitwiseAndWrapper

private ArithmeticBitwiseAndWrapper ::= ArithmeticAdditiveWrapper ArithmeticBitwiseAndExpression*
left ArithmeticBitwiseAndExpression ::= '&' ArithmeticAdditiveWrapper

private ArithmeticAdditiveWrapper ::= ArithmeticMultiplicativeWrapper ArithmeticAdditiveExpression*
left ArithmeticAdditiveExpression ::= ('+' | '-') ArithmeticMultiplicativeWrapper

private ArithmeticMultiplicativeWrapper ::= ArithmeticValueExpression ArithmeticMultiplicativeExpression*
left ArithmeticMultiplicativeExpression ::= ('*' | '/' | '%') ArithmeticValueExpression

ArithmeticValueExpression ::= ('(' ArithmeticExpression ')') | Expression

// General Expressions
Expression ::= ParExpression
             | ArrayVariableExpression
             | LocalVariableExpression
             | ScopedVariableExpression
             | LiteralExpression
             | CommandExpression
             | GosubExpression
             | ConstantExpression
             | DynamicExpression
             | CalcExpression

CalcExpression ::= CALC '(' ArithmeticExpression ')'
private ExpressionList ::= Expression (',' Expression)*
ParExpression ::= '(' Expression ')'

LocalVariableExpression ::= DOLLAR NameLiteral {
    mixin="io.runescript.plugin.lang.psi.impl.naned.RsNamedElementImpl"
    implements="io.runescript.plugin.lang.psi.named.RsNamedElement"
    methods=[getName setName getNameIdentifier]
}

ArrayVariableExpression ::= LocalVariableExpression '(' Expression ')'
ScopedVariableExpression ::= '%' NameLiteral
private LiteralExpression ::= IntegerLiteralExpression
                             | BooleanLiteralExpression
                             | NullLiteralExpression
                             | StringLiteralExpression
IntegerLiteralExpression ::= INTEGER
BooleanLiteralExpression ::= TRUE | FALSE
NullLiteralExpression ::= NULL
StringLiteralExpression ::= STRING_START (STRING_PART | STRING_TAG | StringInterpolationExpression)* STRING_END
StringInterpolationExpression ::= STRING_INTERPOLATION_START | Expression | STRING_INTERPOLATION_END
ConstantExpression ::= '^' NameLiteral
CommandExpression ::= NameLiteral ('(' ExpressionList? ')')?
GosubExpression ::= '~' NameLiteral ('(' ExpressionList? ')')?
DynamicExpression ::= NameLiteral
NameLiteral ::= IDENTIFIER | DEFINE_TYPE | ARRAY_TYPE_NAME | WHILE | IF | TRUE | FALSE | NULL | SWITCH | CASE